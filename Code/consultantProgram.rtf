{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green120\blue215;\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red0\green0\blue255;\red128\green0\blue128;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title consultantProgram.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0\i /***********************************************************************
\par  *consultantProgram.c
\par  *A program that allows consultants to see patient's details
\par  *Candidate number: 181355
\par  *12/2017
\par  **********************************************************************/
\par \i0\cf1 #include <stdio.h>
\par #include <string.h>
\par 
\par #define HEADERLEN 48  \cf0\i /* must be less than or equal to PADDING length */
\par \i0\cf1 #define PADDING "======================================================"
\par #define OR ||
\par #define AND &&
\par #define NAMELIM 26
\par #define FILELIM 51
\par #define LIMIT 1000
\par #define DATELIM 11
\par #define FLOATLIM 9
\par 
\par \cf2\b struct\b0  DOB
\par \cf3\b \{
\par \b0\cf2     \b int\b0  day\cf3\b ;
\par \b0\cf2     \b int\b0  month\cf3\b ;
\par \b0\cf2     \b int\b0  year\cf3\b ;
\par \};
\par 
\par \cf2 struct\b0  patientInfo
\par \cf3\b \{
\par \b0\cf2     \b char\b0  name\cf3\b [\b0\cf2 NAMELIM\cf3\b ];
\par \b0\cf2     \b char\b0  date\cf3\b [\b0\cf2 DATELIM\cf3\b ];
\par \b0\cf2     \b char\b0  height\cf3\b [\b0\cf2 FLOATLIM\cf3\b ];
\par \b0\cf2     \b char\b0  waist\cf3\b [\b0\cf2 FLOATLIM\cf3\b ];
\par \b0\cf2     \b char\b0  weight\cf3\b [\b0\cf2 FLOATLIM\cf3\b ];
\par \b0\cf2     \b char\b0  comment\cf3\b [\b0\cf2 LIMIT\cf3\b ];\b0\cf2   
\par \cf3\b \};
\par 
\par \cf2 void\b0  pressAnyToContinue\cf3\b ();
\par \b0\cf2 _Bool confirmYN\cf3\b (\cf2 char\cf3 []);
\par \cf2 void\b0  equalsLine\cf3\b ();
\par \cf2 void\b0  emptyBuffer\cf3\b ();
\par \cf2 void\b0  displayTitle\cf3\b ();
\par \cf2 void\b0  getPatientName\cf3\b (\cf2 char\cf3 []);
\par \cf2 void\b0  getFileName\cf3\b (\cf2 char\cf3 [],\b0\cf2  \b struct\b0  DOB\cf3\b );
\par \cf2 void\b0  openFile\cf3\b (\cf2 char\cf3 [],\b0\cf2  \b char\cf3 []);
\par \cf2 void\b0  editComment\cf3\b (\cf2 struct\b0  patientInfo\cf3\b ,\b0\cf2  \b char\cf3 []);
\par \cf2 void\b0  writeNewFile\cf3\b (\cf2 struct\b0  patientInfo\cf3\b ,\b0\cf2  \b char\cf3 [],\cf2 char\cf3 []);
\par \cf2 void\b0  decrypt\cf3\b (\cf2 char\cf3 [],\b0\cf2  \b char\cf3 []);
\par \cf2 char\b0  offset\cf3\b (\cf2 char\cf3 ,\b0\cf2  \b char\cf3 ,\b0\cf2  \b char\cf3 );
\par \cf2 void\b0  encrypt\cf3\b (\cf2 char\cf3 [],\b0\cf2  \b char\cf3 []);
\par \cf2 char\b0  offsetEnc\cf3\b (\cf2 char\cf3 ,\b0\cf2  \b char\cf3 ,\b0\cf2  \b char\cf3 );
\par 
\par \b0\cf0\i /*main entry point*/
\par \i0\cf2\b int\b0  main\cf3\b (\cf2 void\cf3 )
\par \{
\par \b0\cf2     \b char\b0  patientName\cf3\b [\b0\cf2 NAMELIM\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  \cf3\b \{\b0\cf2 '\\0'\cf3\b \};
\par \b0\cf2     
\par     displayTitle\cf3\b (\cf4 "Patient Data Viewing"\cf3 );
\par \b0\cf2     printf\cf3\b (\cf4 "\\nWelcome"\cf3 );
\par \b0\cf2     getPatientName\cf3\b (\b0\cf2 patientName\cf3\b );
\par \b0\cf2     
\par     \b return\b0  \cf5 0\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*gets user to input patient's last name and D.O.B*/
\par \i0\cf2\b void\b0  getPatientName\cf3\b (\cf2 char\b0  patientName\cf3\b [])
\par \{
\par \b0\cf2     \b struct\b0  DOB enteredDOB\cf3\b ;
\par \b0\cf2     
\par 
\par     printf\cf3\b (\cf4 "\\n\\nPlease input a patient's last name: "\cf3 );
\par \b0\cf2     scanf\cf3\b (\cf4 "%s"\cf3 ,\b0\cf2  patientName\cf3\b );
\par \b0\cf2     printf\cf3\b (\cf4 "\\nEnter the patient's D.O.B in the form (DD/MM/YYYY): "\cf3 );
\par \b0\cf2     \b while\cf3 (\b0\cf2 scanf\cf3\b (\cf4 "%d/%d/%d"\cf3 ,\b0\cf2  \cf3\b &\b0\cf2 enteredDOB\cf3\b .\b0\cf2 day\cf3\b ,\b0\cf2  \cf3\b &\b0\cf2 enteredDOB\cf3\b .\b0\cf2 month\cf3\b ,\b0\cf2  
\par         \cf3\b &\b0\cf2 enteredDOB\cf3\b .\b0\cf2 year\cf3\b )\b0\cf2  \cf3\b !=\b0\cf2  \cf5 3\cf2  OR enteredDOB\cf3\b .\b0\cf2 day \cf3\b <\b0\cf2  \cf5 1\cf2  OR enteredDOB\cf3\b .\b0\cf2 day \cf3\b >
\par \b0\cf2         \cf5 31\cf2  OR enteredDOB\cf3\b .\b0\cf2 month \cf3\b <\b0\cf2  \cf5 1\cf2  OR enteredDOB\cf3\b .\b0\cf2 month \cf3\b >\b0\cf2  \cf5 12\cf2  OR 
\par         enteredDOB\cf3\b .\b0\cf2 year \cf3\b <\b0\cf2  \cf5 1900\cf2  OR enteredDOB\cf3\b .\b0\cf2 year \cf3\b >\b0\cf5 2017\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         printf\cf3\b (\cf4 "\\nInvalid value"\cf3 );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nPlease try again: "\cf3 );
\par \b0\cf2         emptyBuffer\cf3\b ();
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     
\par     \cf0\i /*creates file name*/
\par \i0\cf2     getFileName\cf3\b (\b0\cf2 patientName\cf3\b ,\b0\cf2  enteredDOB\cf3\b );
\par \b0\cf2     
\par \cf3\b \}
\par 
\par \b0\cf0\i /*creates a file name using information from user*/
\par \i0\cf2\b void\b0  getFileName\cf3\b (\cf2 char\b0  patientName\cf3\b [],\b0\cf2  \b struct\b0  DOB enteredDOB\cf3\b )
\par \{
\par \b0\cf2     \b char\b0  fileName\cf3\b [\b0\cf2 FILELIM\cf3\b ];
\par \b0\cf2     
\par     \cf0\i /*uses last name and D.O.B*/
\par \i0\cf2     sprintf\cf3\b (\b0\cf2 fileName\cf3\b ,\b0\cf2  \cf4\b "%s%04d%02d%02d.aow\\0"\cf3 ,\b0\cf2  patientName\cf3\b ,
\par \b0\cf2         enteredDOB\cf3\b .\b0\cf2 year\cf3\b ,\b0\cf2 enteredDOB\cf3\b .\b0\cf2 month\cf3\b ,\b0\cf2 enteredDOB\cf3\b .\b0\cf2 day\cf3\b );
\par \b0\cf2     printf\cf3\b (\cf4 "\\nFile name:  [%s]\\n"\cf3 ,\b0\cf2  fileName\cf3\b );
\par \b0\cf2     
\par     \cf0\i /*opens file with created file name*/
\par \i0\cf2     openFile\cf3\b (\b0\cf2 fileName\cf3\b ,\b0\cf2  patientName\cf3\b );
\par \}
\par 
\par \cf2 void\b0  openFile\cf3\b (\cf2 char\b0  fileName\cf3\b [],\b0\cf2  \b char\b0  patientName\cf3\b [])
\par \{
\par \b0\cf2     FILE \cf3\b *\b0\cf2 ptrFile\cf3\b ;
\par \b0\cf2     
\par     \b char\b0  tmp\cf3\b [\b0\cf2 LIMIT\cf3\b ];\b0\cf2  
\par 
\par     \b struct\b0  patientInfo patient\cf3\b ;
\par \b0\cf2     
\par     \cf0\i /*attempts to open file with created filename*/
\par \i0\cf2     ptrFile \cf3\b =\b0\cf2  fopen\cf3\b (\b0\cf2 fileName\cf3\b ,\b0\cf2  \cf4\b "r"\cf3 );
\par \b0\cf2     
\par     \cf0\i /*could file be opened?*/
\par \i0\cf2     \b if\b0  \cf3\b (!\b0\cf2 ptrFile\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf0\i /*file not opened*/
\par \i0\cf2         printf\cf3\b (\cf4 "\\nPatient not found\\n"\cf3 );
\par \b0\cf2         \cf0\i /*does the user want to search again*/
\par \i0\cf2         \b if\cf3 (\b0\cf2 confirmYN\cf3\b (\cf4 "Do you want to try again?(Y/N): "\cf3 )\b0\cf2  \cf3\b ==\b0\cf2  \cf5 1\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             getPatientName\cf3\b (\b0\cf2 patientName\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \b else
\par \b0     \cf3\b \{
\par \b0\cf2         \cf0\i /*file opened so information is read from file into temporary*/\i0\cf2  
\par         \cf0\i /*buffer, then decrypted and stored in the patient info struct*/
\par \i0\cf2          
\par         fscanf\cf3\b (\b0\cf2 ptrFile\cf3\b ,\b0\cf2  \cf4\b "%51[^\\n]"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         decrypt\cf3\b (\b0\cf2 tmp\cf3\b ,\b0\cf2 patient\cf3\b .\b0\cf2 name\cf3\b );\b0\cf2  
\par         fscanf\cf3\b (\b0\cf2 ptrFile\cf3\b ,\b0\cf2  \cf4\b "%s"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         decrypt\cf3\b (\b0\cf2 tmp\cf3\b ,\b0\cf2  patient\cf3\b .\b0\cf2 date\cf3\b );
\par \b0\cf2         fscanf\cf3\b (\b0\cf2 ptrFile\cf3\b ,\b0\cf2  \cf4\b "%s"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         decrypt\cf3\b (\b0\cf2 tmp\cf3\b ,\b0\cf2  patient\cf3\b .\b0\cf2 height\cf3\b );
\par \b0\cf2         fscanf\cf3\b (\b0\cf2 ptrFile\cf3\b ,\b0\cf2  \cf4\b "%s"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         decrypt\cf3\b (\b0\cf2 tmp\cf3\b ,\b0\cf2  patient\cf3\b .\b0\cf2 waist\cf3\b );\b0\cf2   
\par         fscanf\cf3\b (\b0\cf2 ptrFile\cf3\b ,\b0\cf2  \cf4\b "%s"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         decrypt\cf3\b (\b0\cf2 tmp\cf3\b ,\b0\cf2  patient\cf3\b .\b0\cf2 weight\cf3\b );
\par \b0\cf2         fscanf\cf3\b (\b0\cf2 ptrFile\cf3\b ,\b0\cf2  \cf4\b "\\n%1000[^\\n]"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         decrypt\cf3\b (\b0\cf2 tmp\cf3\b ,\b0\cf2  patient\cf3\b .\b0\cf2 comment\cf3\b );
\par \b0\cf2     
\par         \cf0\i /*closes patient file*/
\par \i0\cf2         fclose\cf3\b (\b0\cf2 ptrFile\cf3\b );
\par \b0\cf2         
\par         \cf0\i /*displays decrypted patient info on screen*/
\par \i0\cf2         printf\cf3\b (\cf4 "\\n"\cf3 );
\par \b0\cf2         displayTitle\cf3\b (\b0\cf2 patient\cf3\b .\b0\cf2 name\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nPatient D.O.B:      %s"\cf3 ,\b0\cf2  patient\cf3\b .\b0\cf2 date\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nPatient Height(cm): %s"\cf3 ,\b0\cf2  patient\cf3\b .\b0\cf2 height\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nPatient Waist(cm):  %s"\cf3 ,\b0\cf2  patient\cf3\b .\b0\cf2 waist\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nPatient Weight(kg): %s"\cf3 ,\b0\cf2  patient\cf3\b .\b0\cf2 weight\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nComment:            %s"\cf3 ,\b0\cf2  patient\cf3\b .\b0\cf2 comment\cf3\b );
\par \b0\cf2         
\par         \cf0\i /*allows user to edit comment stored on file*/
\par \i0\cf2         editComment\cf3\b (\b0\cf2 patient\cf3\b ,\b0\cf2  fileName\cf3\b );
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     
\par \cf3\b \}
\par 
\par \b0\cf0\i /*asks user if they want to add to comments on file, then gets the*/\i0\cf2  
\par \cf0\i /*new comment*/
\par \i0\cf2\b void\b0  editComment\cf3\b (\cf2 struct\b0  patientInfo patient\cf3\b ,\b0\cf2  \b char\b0  fileName\cf3\b [])
\par \{
\par \b0\cf2     \b char\b0  newNote\cf3\b [\b0\cf2 LIMIT\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  \cf3\b \{\b0\cf2 '\\0'\cf3\b \};
\par 
\par 
\par \b0\cf2     \b if\cf3 (\b0\cf2 confirmYN\cf3\b (\cf4 "\\n\\nDo you want to add notes to the comment?(Y/N): "\cf3 )\b0\cf2    
\par         \cf3\b ==\b0\cf2  \cf5 1\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf0\i /*if yes, get new comment*/
\par \i0\cf2         printf\cf3\b (\cf4 "\\nEnter notes to be added to comments: "\cf3 );
\par \b0\cf2         emptyBuffer\cf3\b ();
\par \b0\cf2         scanf\cf3\b (\cf4 "%[^\\n]"\cf3 ,\b0\cf2  newNote\cf3\b );
\par \b0\cf2         printf\cf3\b (\cf4 "\\nNew notes: %s"\cf3 ,\b0\cf2  newNote\cf3\b );
\par \b0\cf2         \cf0\i /*writes file with new comment*/
\par \i0\cf2         writeNewFile\cf3\b (\b0\cf2 patient\cf3\b ,\b0\cf2  fileName\cf3\b ,\b0\cf2  newNote\cf3\b );\b0\cf2    
\par     \cf3\b \}
\par \b0\cf2     \cf0\i /*if no program will close*/
\par \i0\cf3\b \}
\par 
\par \b0\cf0\i /*decrypts a string*/
\par \i0\cf2\b void\b0  decrypt\cf3\b (\cf2 char\b0  encrypted\cf3\b [],\b0\cf2  \b char\b0  unEncrypted\cf3\b [])
\par \{
\par \b0\cf2     \b int\b0  ii\cf3\b =\b0\cf5 0\cf3\b ;
\par \b0\cf2     \b char\b0  ch \cf3\b =\b0\cf2  '\\0'\cf3\b ;
\par \b0\cf2     
\par     \cf0\i /*loops through encrypted string*/
\par \i0\cf2     \b for\cf3 (\b0\cf2 ii\cf3\b =\b0\cf5 0\cf3\b ;\b0\cf2  encrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b !=\b0\cf2  '\\0'\cf3\b ;\b0\cf2  ii\cf3\b ++)
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         ch \cf3\b =\b0\cf2  encrypted\cf3\b [\b0\cf2 ii\cf3\b ];
\par \b0\cf2        
\par         \b if\cf3 (\b0\cf2 ch \cf3\b >=\b0\cf2  'A' \cf3\b &&\b0\cf2  ch \cf3\b <=\b0\cf2  'Z'\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             \cf0\i /*apply offset to upper case alpha*/
\par \i0\cf2             unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  offset\cf3\b (\b0\cf2 'Z'\cf3\b ,\b0\cf2 'A'\cf3\b ,\b0\cf2  ch\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b else
\par \b0         \b if\cf3 (\b0\cf2 ch \cf3\b >=\b0\cf2  'a' \cf3\b &&\b0\cf2  ch \cf3\b <=\b0\cf2  'z'\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             \cf0\i /*apply offset to lower case alpha*/
\par \i0\cf2             unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  offset\cf3\b (\b0\cf2 'z'\cf3\b ,\b0\cf2 'a'\cf3\b ,\b0\cf2  ch\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b else
\par \b0         \b if\cf3 (\b0\cf2 ch \cf3\b >=\b0\cf2  '0' \cf3\b &&\b0\cf2  ch \cf3\b <=\b0\cf2  '9'\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             \cf0\i /*apply offset to digit*/
\par \i0\cf2             unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  offset\cf3\b (\b0\cf2 '9'\cf3\b ,\b0\cf2 '0'\cf3\b ,\b0\cf2  ch\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b else
\par \b0         \cf3\b \{
\par \b0\cf2             \cf0\i /*no decryption applied to char outside of specified range*/
\par \i0\cf2             unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  ch\cf3\b ;
\par \b0\cf2         \cf3\b \}
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \cf0\i /*terminate unencrypted string*/
\par \i0\cf2     unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  '\\0'\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*applies decryption key to a character, wrapping around when needed*/
\par \i0\cf2\b char\b0  offset\cf3\b (\cf2 char\b0  top\cf3\b ,\b0\cf2  \b char\b0  bottom\cf3\b ,\b0\cf2  \b char\b0  src\cf3\b )
\par \{
\par \b0\cf2     \cf0\i /*range is difference between height and lowest value in range*/
\par \i0\cf2     \b int\b0  range \cf3\b =\b0\cf2  \cf3\b (\b0\cf2 top \cf3\b -\b0\cf2  bottom\cf3\b )\b0\cf2  \cf3\b +\b0\cf2  \cf5 1\cf3\b ;
\par \b0\cf2     \cf0\i /*decryption/encryption key*/
\par \i0\cf2     \b int\b0  offset \cf3\b =\b0\cf2  \cf5 7\cf3\b ;
\par \b0\cf2     \cf0\i /*wraparound encryption/decryption key*/
\par \i0\cf2     \b int\b0  offset1 \cf3\b =\b0\cf2  range \cf3\b -\b0\cf2  offset\cf3\b ;
\par \b0\cf2     \b char\b0  ch \cf3\b =\b0\cf2  src\cf3\b ;
\par \b0\cf2     
\par     \cf0\i /*do we need to wraparound?*/
\par \i0\cf2     \b if\cf3 (\b0\cf2 ch \cf3\b <\b0\cf2  \cf3\b (\b0\cf2 bottom \cf3\b +\b0\cf2  offset\cf3\b ))
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf0\i /*yes*/
\par \i0\cf2         ch \cf3\b +=\b0\cf2  offset1\cf3\b ;
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \b else
\par \b0     \cf3\b \{
\par \b0\cf2         \cf0\i /*no*/
\par \i0\cf2         ch \cf3\b -=\b0\cf2  offset\cf3\b ;
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     
\par     \cf0\i /*return decrypted character*/
\par \i0\cf2     \b return\b0  ch\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*writes a file with encrypted data using previosuly created filename*/
\par \i0\cf2\b void\b0  writeNewFile\cf3\b (\cf2 struct\b0  patientInfo patient\cf3\b ,\b0\cf2  \b char\b0  fileName\cf3\b [],
\par \b0\cf2     \b char\b0  newNote\cf3\b [])
\par \{
\par \b0\cf2     FILE \cf3\b *\b0\cf2 filePtr\cf3\b ;
\par \b0\cf2     \b char\b0  tmp\cf3\b [\b0\cf2 LIMIT\cf3\b ];
\par \b0\cf2     \b char\b0  tmp1\cf3\b [\b0\cf2 LIMIT\cf3\b ];
\par \b0\cf2     
\par     filePtr \cf3\b =\b0\cf2  fopen\cf3\b (\b0\cf2 fileName\cf3\b ,\b0\cf2  \cf4\b "w"\cf3 );
\par \b0\cf2     \b if\b0  \cf3\b (!\b0\cf2 filePtr\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf0\i /* error message if file cannot be written*/
\par \i0\cf2         printf\cf3\b (\cf4 "\\nFile not created\\n"\cf3 );
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \b else
\par \b0     \cf3\b \{
\par \b0\cf2         \cf0\i /*encrypts data then prints to file*/
\par \i0\cf2         encrypt\cf3\b (\b0\cf2 patient\cf3\b .\b0\cf2 name\cf3\b ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         fprintf\cf3\b (\b0\cf2 filePtr\cf3\b ,\b0\cf2  \cf4\b "%s\\n"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         encrypt\cf3\b (\b0\cf2 patient\cf3\b .\b0\cf2 date\cf3\b ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         fprintf\cf3\b (\b0\cf2 filePtr\cf3\b ,\b0\cf2  \cf4\b "%s\\n"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         encrypt\cf3\b (\b0\cf2 patient\cf3\b .\b0\cf2 height\cf3\b ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         fprintf\cf3\b (\b0\cf2 filePtr\cf3\b ,\b0\cf2  \cf4\b "%s\\n"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         encrypt\cf3\b (\b0\cf2 patient\cf3\b .\b0\cf2 waist\cf3\b ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         fprintf\cf3\b (\b0\cf2 filePtr\cf3\b ,\b0\cf2  \cf4\b "%s\\n"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         encrypt\cf3\b (\b0\cf2 patient\cf3\b .\b0\cf2 weight\cf3\b ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         fprintf\cf3\b (\b0\cf2 filePtr\cf3\b ,\b0\cf2  \cf4\b "%s\\n"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         sprintf\cf3\b (\b0\cf2 tmp1\cf3\b ,\b0\cf2  \cf4\b "%s %s"\cf3 ,\b0\cf2  patient\cf3\b .\b0\cf2 comment\cf3\b ,\b0\cf2  newNote\cf3\b );
\par \b0\cf2         encrypt\cf3\b (\b0\cf2 tmp1\cf3\b ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         fprintf\cf3\b (\b0\cf2 filePtr\cf3\b ,\b0\cf2  \cf4\b "%s\\n"\cf3 ,\b0\cf2  tmp\cf3\b );
\par \b0\cf2         
\par         fclose\cf3\b (\b0\cf2 filePtr\cf3\b );
\par \b0\cf2         
\par         printf\cf3\b (\cf4 "\\nFile written succesfully"\cf3 );
\par \b0\cf2         
\par     \cf3\b \}
\par \b0\cf2     
\par \cf3\b \}
\par 
\par \b0\cf0\i /*encrypts a string*/
\par \i0\cf2\b void\b0  encrypt\cf3\b (\cf2 char\b0  unEncrypted\cf3\b [],\b0\cf2  \b char\b0  encrypted\cf3\b [])
\par \{
\par \b0\cf2     \b int\b0  ii\cf3\b =\b0\cf5 0\cf3\b ;
\par \b0\cf2     \b char\b0  ch \cf3\b =\b0\cf2  '\\0'\cf3\b ;
\par \b0\cf2     
\par     \cf0\i /*loops through unencrypted string*/
\par \i0\cf2     \b for\cf3 (\b0\cf2 ii\cf3\b =\b0\cf5 0\cf3\b ;\b0\cf2  unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b !=\b0\cf2  '\\0'\cf3\b ;\b0\cf2  ii\cf3\b ++)
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         ch \cf3\b =\b0\cf2  unEncrypted\cf3\b [\b0\cf2 ii\cf3\b ];
\par \b0\cf2         
\par         \b if\cf3 (\b0\cf2 ch \cf3\b >=\b0\cf2  'a' \cf3\b &&\b0\cf2  ch \cf3\b <=\b0\cf2  'z'\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             \cf0\i /*apply encryption offset to lower case alpha*/
\par \i0\cf2             encrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  offsetEnc\cf3\b (\b0\cf2 'z'\cf3\b ,\b0\cf2  'a'\cf3\b ,\b0\cf2  ch\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b else
\par \b0         \b if\cf3 (\b0\cf2 ch \cf3\b >=\b0\cf2  'A' \cf3\b &&\b0\cf2  ch \cf3\b <=\b0\cf2  'Z'\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             \cf0\i /*apply encryption offset to upper case alpha*/
\par \i0\cf2             encrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  offsetEnc\cf3\b (\b0\cf2 'Z'\cf3\b ,\b0\cf2  'A'\cf3\b ,\b0\cf2  ch\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b else
\par \b0         \b if\cf3 (\b0\cf2 ch \cf3\b >=\b0\cf2  '0' \cf3\b &&\b0\cf2  ch \cf3\b <=\b0\cf2  '9'\cf3\b )
\par \b0\cf2         \cf3\b \{
\par \b0\cf2             \cf0\i /*apply encryption offset to digit*/
\par \i0\cf2             encrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  offsetEnc\cf3\b (\b0\cf2 '9'\cf3\b ,\b0\cf2  '0'\cf3\b ,\b0\cf2  ch\cf3\b );
\par \b0\cf2         \cf3\b \}
\par \b0\cf2         \b else
\par \b0         \cf3\b \{
\par \b0\cf2             \cf0\i /*no encryption applied to char outside specified ranges*/
\par \i0\cf2             encrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  ch\cf3\b ;
\par \b0\cf2         \cf3\b \}
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \cf0\i /*terminate encrypted string*/
\par \i0\cf2     encrypted\cf3\b [\b0\cf2 ii\cf3\b ]\b0\cf2  \cf3\b =\b0\cf2  '\\0'\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*applies encryption key to a character, wrapping appropriately*/
\par \i0\cf2\b char\b0  offsetEnc\cf3\b (\cf2 char\b0  top\cf3\b ,\b0\cf2  \b char\b0  bottom\cf3\b ,\b0\cf2  \b char\b0  ch\cf3\b )
\par \{
\par \b0\cf2     \cf0\i /*range is difference between highest and lowest value in range*/
\par \i0\cf2     \b int\b0  range \cf3\b =\b0\cf2  \cf3\b (\b0\cf2 top \cf3\b -\b0\cf2  bottom\cf3\b )\b0\cf2  \cf3\b +\b0\cf2  \cf5 1\cf3\b ;
\par \b0\cf2     \cf0\i /*encryption key*/
\par \i0\cf2     \b int\b0  offset \cf3\b =\b0\cf2  \cf5 7\cf3\b ;
\par \b0\cf2     \cf0\i /*wraparound encryption key*/
\par \i0\cf2     \b int\b0  offset1 \cf3\b =\b0\cf2  range \cf3\b -\b0\cf2  offset\cf3\b ;
\par \b0\cf2     \b char\b0  cc \cf3\b =\b0\cf2  ch\cf3\b ;
\par \b0\cf2     
\par     \cf0\i /*do we need to wraparound?*/
\par \i0\cf2     \b if\cf3 (\b0\cf2 cc \cf3\b >\b0\cf2  \cf3\b (\b0\cf2 top \cf3\b -\b0\cf2  offset\cf3\b ))
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf0\i /*yes*/
\par \i0\cf2         cc \cf3\b -=\b0\cf2  offset1\cf3\b ;
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     \b else
\par \b0     \cf3\b \{
\par \b0\cf2         \cf0\i /*no*/
\par \i0\cf2         cc \cf3\b +=\b0\cf2  offset\cf3\b ;
\par \b0\cf2     \cf3\b \}
\par 
\par \b0\cf2     \cf0\i /*return encrypted character*/
\par \i0\cf2     \b return\b0  cc\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*waits for user input*/
\par \i0\cf2\b void\b0  pressAnyToContinue\cf3\b ()
\par \{
\par \b0\cf2     printf\cf3\b (\cf4 "\\nPress any key to continue"\cf3 );
\par \b0\cf2     _getch\cf3\b ();
\par \}
\par 
\par \b0\cf0\i /*this function is used for every (Y/N) question */
\par \i0\cf2 _Bool confirmYN\cf3\b (\cf2 char\b0  \cf3\b *\b0\cf2 message\cf3\b )
\par \{
\par \b0\cf2     _Bool result \cf3\b =\b0\cf2  \cf5 0\cf3\b ;
\par 
\par \b0\cf2     \cf0\i /*show the question prompt*/
\par \i0\cf2     printf\cf3\b (\b0\cf2 message\cf3\b );
\par 
\par \b0\cf2     \cf0\i /* get their answer */
\par \i0\cf2     \b char\b0  answer \cf3\b =\b0\cf2  '\\0'\cf3\b ;
\par \b0\cf2     emptyBuffer\cf3\b ();
\par \b0\cf2     
\par     \b while\cf3 ((\b0\cf2 scanf\cf3\b (\cf4 "%c"\cf3 ,\b0\cf2  \cf3\b &\b0\cf2 answer\cf3\b )\b0\cf2  \cf3\b !=\b0\cf2  \cf5 1\cf3\b )\b0\cf2  OR \cf3\b (\b0\cf2 answer \cf3\b !=\b0\cf2  'Y' AND 
\par             answer \cf3\b !=\b0\cf2  'y' AND answer \cf3\b !=\b0\cf2  'N' AND answer \cf3\b !=\b0\cf2  'n'\cf3\b ))
\par \b0\cf2 	\cf3\b \{\b0\cf2 	
\par     	printf\cf3\b (\cf4 "Invalid answer\\n"\cf3 );\b0\cf2    
\par         printf\cf3\b (\cf4 "Please try again: "\cf3 );
\par \b0\cf2     	emptyBuffer\cf3\b ();\b0\cf2                 
\par 	\cf3\b \}
\par 
\par \b0\cf2     \b if\b0  \cf3\b (\b0\cf2 answer \cf3\b ==\b0\cf2  'y' OR answer \cf3\b ==\b0\cf2  'Y'\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf0\i /* confirmed */
\par \i0\cf2         result \cf3\b =\b0\cf2  \cf5 1\cf3\b ;
\par \b0\cf2     \cf3\b \}
\par 
\par \b0\cf2     \b return\b0  result\cf3\b ;
\par \}
\par 
\par \b0\cf0\i /*displays title between two lines of '=' */
\par \i0\cf2\b void\b0  displayTitle\cf3\b (\cf2 char\b0  \cf3\b *\b0\cf2 title\cf3\b )
\par \{
\par \b0\cf2     equalsLine\cf3\b ();
\par 
\par \b0\cf2     \cf0\i /* calculate available space on line / 2*/
\par \i0\cf2     \b int\b0  len \cf3\b =\b0\cf2  \cf3\b (\b0\cf2 HEADERLEN\cf3\b -\b0\cf2 strlen\cf3\b (\b0\cf2 title\cf3\b ))/\b0\cf5 2\cf3\b ;
\par \b0\cf2     
\par     \cf0\i /*prints the title padded with appropriate number of spaces*/
\par \i0\cf2     printf\cf3\b (\cf4 "%*.*s%s\\n"\cf3 ,\b0\cf2  len\cf3\b ,\b0\cf2  len\cf3\b ,\b0\cf2  \cf4\b " "\cf3 ,\b0\cf2  title\cf3\b );
\par \b0\cf2     
\par     equalsLine\cf3\b ();
\par \}
\par 
\par \b0\cf0\i /*prints out a line of equals of length constant PADDING */
\par \i0\cf2\b void\b0  equalsLine\cf3\b ()
\par \{
\par \b0\cf2     printf\cf3\b (\cf4 "%*.*s\\n"\cf3 ,\b0\cf2  HEADERLEN\cf3\b ,\b0\cf2  HEADERLEN\cf3\b ,\b0\cf2  PADDING\cf3\b );
\par \}
\par 
\par \b0\cf0\i /*clears the buffer */
\par \i0\cf2\b void\b0  emptyBuffer\cf3\b ()
\par \{
\par \b0\cf2     \b while\cf3 (\b0\cf2 getchar\cf3\b ()\b0\cf2  \cf3\b !=\b0\cf2  '\\n'\cf3\b )
\par \b0\cf2     \cf3\b \{
\par \b0\cf2         \cf3\b ;
\par \b0\cf2     \cf3\b \}
\par \}
\par }